<!DOCTYPE html>
<html>
  <head>
    <title>Khan Academy Challenge Framework</title>
    <link rel="stylesheet" type="text/css" href="scss/output.css">
    <style type="text/css" media="screen">
    #editor {
        position: relative;
        height: 500px;
        width: 100%;
/*        top: 0;
        right: 0;
        bottom: 0;
        left: 0;*/
    }
  </style>
  </head>
  <body>
    <div class="title">khan academy challenge</div>
    <div>We'd like to be able to have a few testing APIs to work with, namely:</div>

    <ul>

      <li>A whitelist of specific functionality. For example, the ability to say "This program MUST use a 'for loop' and a 'variable declaration'."</li>

      <li>A blacklist of specific functionality. For example, the ability to say "This program MUST NOT use a 'while loop' or an 'if statement'."</li>


      <li>Determine the rough structure of the program. For example, "There should be a 'for loop' and inside of it there should be an 'if statement'."</li>

    </ul>

    <ul>
      <!-- instead of adding in notifications here, we can input them into the function and append it to our ul -->
      <li class="for">Great job!  We input a for loop!</li>
      <li class="var">Good going!  We have a variable declaration!</li>
      <li class="while">We're trying to avoid while loops! Please remove!</li>
      <li class="if">Let's stray away from 'if' statements! Please remove!</li>
      <li class="roughStructure">There is no if statement within a for loop!</li>
    </ul>
    <div id="editor">function foo(items) {
  for (var i = 0; i < 5; i++) {
    for (var j = 0; j < 5; j++) {
      if ('lol' == 'lol') {
        console.log('lolol!!')
        if ('lolool' == 'lolool') {
          console.log('lololol!!!');
        }
      }
      console.log(j);
    }
    console.log(i);
  }
  if ('test' === 'test') {
    console.log('lol');
  }
  if ('test' === 'test') {
    console.log('lol');
  }
}</div>
    <div class="output"></div>
    <script src="https://code.jquery.com/jquery-2.2.1.js" integrity="sha256-eNcUzO3jsv0XlJLveFEkbB8bA7/CroNpNVk3XpmnwHc=" crossorigin="anonymous"></script>
    <script type="text/javascript" src="src/ace/src-min-noconflict/ace.js"></script>
    <script type="text/javascript" src="node_modules/acorn/dist/acorn.js" charset="UTF-8"></script>
    <script type="text/javascript" src="node_modules/acorn/dist/acorn_loose.js" charset="UTF-8"></script>
    <script type="text/javascript" src="js/app.js"></script>
    <script>
      'use strict';
      //editor
      var editor = ace.edit("editor");
      editor.setTheme("ace/theme/monokai");
      editor.getSession().setMode("ace/mode/javascript");

      //acorn parser
      var tokens = [];
      var acEx = acorn.parse(editor.getValue());
      // console.log('acorn example: ', acEx);

      //**SOLVES BLACKLIST AND WHITELIST, BUT NOT STRUCTURE...

      // FOR ROUGH STRUCTURE
      function setUpStructure(tree) {
        //local var to hold the types in our tree
        var treeTypes = [];

        function parseTree(node) {

          var current = node;

          //parse through tree
          while (current.body || current.consequent) {

            current = current.body || current.consequent;
            // console.log("current is: ", current);

            if (Array.isArray(current)) {
              for (var i = 0; i < current.length; i++) {
                // console.log('parseTree is triggered with: ', current[i]);
                treeTypes.push([current[i].type, current[i].start, current[i].end]);
                parseTree(current[i]);
              }
            }

            if (current.type) {
              // console.log('current.type is: ', current.type);
              treeTypes.push([current.type, current.start, current.end]);
            }

          }
          //go through and get every node type and then create a new hash and push the hash into the arr
          // return treeTypes;

        }

        parseTree(tree);

        return treeTypes;

      }

      function checkForStructure(treeTypes, arrOfTypes, notifArr) {
        //we can iterate through our treeTypes nested arr and check for the first item in the arr
        //then check all other treeTypes[i][0] for the first type, then check all other
        //items in the treeTypes to see if the second type is within the start/end bounds of the first  type,
        //then continue on....

        //nested for loops.
        // 1 loop to go through tree types
        // 1 loop to go through arrOfTypes we enter in
        // if they're equal to one another, then
        // continue looping through other things to find next item...
        // and next item...
        // if all are found, we'll return true
        // if false, we'll return false
        // var treeHash = {
        //   "FunctionDeclaration": [0,8],
        //   "ForStatement": [[1,4],[5,7]],
        //   "IfStatement": [[2,3]]
        // }
        var found = false,
            start = treeTypes[0][1],
            end = treeTypes[0][2],
            startEndArr = [],
            origCopyArrTypes = arrOfTypes.slice(0);

        function recursiveGetStructure(arrOfTreeTypes, arrOfThingsToCheck) {

          for (var i = 0; i < treeTypes.length; i++) {
            // console.log('old start and new:', start + ' ' + end);
            if (treeTypes[i][0] === arrOfTypes[0] && treeTypes[i][1] >= start && treeTypes[i][2] <= end) {
              // console.log('treeTypes[i][0]: ' + treeTypes[i][0] + ' and arrOfTypes[0] ' + arrOfTypes[0]);
              // if statement to return out of function if expressionstatements are found more than once in a row
              start = treeTypes[i][1];
              end = treeTypes[i][2];
              // console.log("new start and end for arrOfTypes[0]:", start + ' ' + end + ' ' + arrOfTypes[0]);
              if (arrOfTypes.length == 1) {
                found = true;
                return;
              }

              var temp = treeTypes.splice(i,1);
              startEndArr.push(temp);
              // console.log('arrOfTypes before: ', arrOfTypes);
              arrOfTypes.shift();
              // console.log('arrOfTypes after: ', arrOfTypes);
              // if we got to last index of arrOfTypes and its a valid type, then we'll change found from false to true



              recursiveGetStructure(arrOfTreeTypes, arrOfThingsToCheck);
              //else if we get to last ind of arrOfTypes and its NOT nested within
              //treeTypes, then we'll change found = false
            }
          }

        }

        recursiveGetStructure(treeTypes, arrOfTypes)

        // console.log(found);
        // return found;
        var ifFound = "Awesome!  There is a ";
        var notFound = "Sorry, we don't have a ";
        console.log("origCopyArrTypes", origCopyArrTypes);
        if (found) {
          for (var j = origCopyArrTypes.length -1; j >= 0; j--) {
            if (j == (origCopyArrTypes.length-1)) {
              ifFound += origCopyArrTypes[j];
            } else {
              ifFound += " within a " + origCopyArrTypes[j];
            }
          }
          ifFound += '.';
          notifArr.push(ifFound);

        } else {
          for (var k = origCopyArrTypes.length -1; k >= 0; k--) {
            if (k == (origCopyArrTypes.length-1)) {
              notFound += origCopyArrTypes[k];
            } else {
              notFound+= " within a " + origCopyArrTypes[k];
            }
          }
          notFound+= '.  Please implement this!';
          notifArr.push(notFound);
        }
      }

      function whiteList(treeTypes, statementSearchingFor, notifArr) {
        for (var i = 0; i < treeTypes.length; i++) {
          if (treeTypes[i][0] === statementSearchingFor) {
            notifArr.push("We were looking for " + statementSearchingFor + " to exist!  Congrats!");
          }
        }
      }

      function blackList(treeTypes, statementSearchingFor, notifArr) {
        for (var i = 0; i < treeTypes.length; i++) {
          if (treeTypes[i][0] === statementSearchingFor) {
            notifArr.push("We were NOT looking for you to have " + statementSearchingFor + " in your code!  Please remove.");
          }
        }
      }

      $(document).ready(function(){
        var treeArr = setUpStructure(acEx);
        var notifArr = [];

        //whitelist
        whiteList(treeArr, 'ForStatement', notifArr);
        whiteList(treeArr, 'IfStatement', notifArr)

        //blacklist
        blackList(treeArr, 'IfStatement', notifArr);

        //rough structure
        checkForStructure(treeArr, ['ForStatement', 'IfStatement', 'WhileStatement'], notifArr)

        for (var i = 0; i < notifArr.length; i++) {

        }

      });

      //on each key entered...
      $('#editor').keyup(function(event) {
        var treeArr = setUpStructure(acEx);
        var notifArr = [];

        //whitelist
        whiteList(treeArr, 'ForStatement', notifArr);
        whiteList(treeArr, 'IfStatement', notifArr)

        //blacklist
        blackList(treeArr, 'IfStatement', notifArr);

        //rough structure
        checkForStructure(treeArr, ['ForStatement', 'IfStatement', 'WhileStatement'], notifArr)

      });

      // var api = {
      // //whitelist testing
      //   whiteList: function(editorCode, codeSearchFor) {
      //     return this.testingCode(editorCode, codeSearchFor);
      //   },
      //   //blacklist testing
      //   blackList: function(editorCode, codeSearchFor) {
      //     return this.testingCode(editorCode, codeSearchFor);
      //   },

      //   //determine rough structure
      //   roughStructure: function(editorCode, arrCodeSearchFor, message) {
      //     var structuralIntegrity = true;
      //     for (var i = 0; i < arrCodeSearchFor.length; i++) {
      //       if (editorCode.search(arrCodeSearchFor[i]) == -1) {
      //         structuralIntegrity = false;
      //       }
      //     }

      //     if (!structuralIntegrity) {
      //       // console.log(message, 'structural integrity is false');
      //       var notification = document.getElementsByClassName('roughStructure');
      //       if (notification[0].style.display = 'none') {
      //         notification[0].style.display = 'block';
      //       }
      //     } else {
      //       var notification = document.getElementsByClassName('roughStructure');
      //       if (notification[0].style.display = 'block') {
      //         notification[0].style.display = 'none';
      //       }
      //     }
      //   },

      //   // default testing our code function
      //   testingCode: function(editorCode, codeSearchFor) {
      //     var notification = document.getElementsByClassName(codeSearchFor);

      //     //go through splitWords and if we find codeSearchFor, then show notification
      //     if (editorCode.search(codeSearchFor) !== -1) {
      //       if (notification[0].style.display = 'none') {
      //         notification[0].style.display = 'block';
      //       }
      //     //go through splitWords and if we DON'T find codeSearchFor, then hide the notification
      //     } else {
      //       if (notification[0].style.display = 'block') {
      //         notification[0].style.display = 'none';
      //       }
      //     }
      //   }
      // }
    </script>
  </body>
</html>
